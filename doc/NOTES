
* <2022-04-24 Sun>

+- [0] D = LAST_REG
+- [1] MUL #2, #3
+--- [2] ROL #4, #5
+----- [4] ADD #6, #7
+------- [6] D = 3d1b58ba
+------- [7] # = 2eb141f2
+----- [5] ROR #8, #9
+------- [8] # = 79e2a9e3
+------- [9] # = 515f007d
+--- [3] # = 74b0dc51

gdb$ disas &encrypt_stage,+0x28
Dump of assembler code from 0x555555563820 to 0x555555563848:
<encrypt_stage+0>:        mov    eax,0x79e2a9e3   ; imm #8
<encrypt_stage+5>:        rol    eax,0x3          ; ror 13 optimized to rol 3!
<encrypt_stage+8>:        mov    ebp,eax
<encrypt_stage+10>:       mov    eax,0xffffffaa   ; load #D
<encrypt_stage+15>:       sub    eax,0x2eb141f2   ; imm #7
<encrypt_stage+20>:       mov    ebx,0x515f007d   ; imm #9
<encrypt_stage+25>:       mov    ecx,ebx          ; XXX this should be bp
<encrypt_stage+27>:       rol    eax,cl           ;
<encrypt_stage+29>:       mov    ebx,eax
<encrypt_stage+31>:       mov    edx,0x74b0dc51   ; imm #3
<encrypt_stage+36>:       mul    edx
<encrypt_stage+38>:       nop                     ; store #D
<encrypt_stage+39>:       ret

* <2022-05-01 Sun> random unbiasing

In the ops tree creation there's a 5% skew towards the ops in 3+[0,3], i.e.
SUB, ADD, XOR, MUL.  This becomes further biased towards SUB and ADD because
after doing a memory op the 0x80 flag goes on the op, which then shifts the
result right, which results in SUB and ADD being picked 17.2% vs 16.4% for
XOR, MUL, ROL, ROR. 

** without a memory load active

- 00 [    22]: ###################### (8.59%)
- 01 [    22]: ###################### (8.59%)
- 02 [    22]: ###################### (8.59%)
- 03 [    22]: ###################### (8.59%)
- 04 [    21]: ##################### (8.20%)
- 05 [    21]: ##################### (8.20%)
- 06 [    21]: ##################### (8.20%)
- 07 [    21]: ##################### (8.20%)
- 08 [    21]: ##################### (8.20%)
- 09 [    21]: ##################### (8.20%)
- 10 [    21]: ##################### (8.20%)
- 11 [    21]: ##################### (8.20%)

** with a memory load active

- 00 [    44]: ############################################ (17.19%)
- 01 [    44]: ############################################ (17.19%)
- 02 [    42]: ########################################## (16.41%)
- 03 [    42]: ########################################## (16.41%)
- 04 [    42]: ########################################## (16.41%)
- 05 [    42]: ########################################## (16.41%)

** and after switching to rnd_n()

- 00 [142883]: ######## (5.12%)
- 01 [142987]: ######## (5.12%)
- 02 [142977]: ######## (5.12%)
- 03 [143550]: ######## (5.14%)
- 04 [143203]: ######## (5.13%)
- 05 [143037]: ######## (5.13%)
- 06 [ 56353]: ### (2.02%)
- 07 [ 56124]: ### (2.01%)
- 08 [ 56062]: ### (2.01%)
- 09 [ 56441]: ### (2.02%)
- 10 [ 55911]: ### (2.00%)
- 11 [ 55914]: ### (2.00%)

... that's better!

** SIGNBIT and enums

I've been converting the raw values into enums, and forgot that they're ints.
For example, SIGNBIT(ops[i]) always returns 0 because it's originally a u8.

** single ref

it does appear that the target load/store can appear 3 times in 8.4% of
generated trees:

- 2 [1831932]: ################################################## (91.60%)
- 3 [168068]: #### (8.40%)

Which lines up with what's in "Mutation Engine Report" (Tarkan Yetiser).

